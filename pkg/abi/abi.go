// Copyright Â© 2022 Kaleido, Inc.
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package abi

import "strings"

// ABI "Application Binary Interface" is a list of the methods and events
// on the external interface of an EVM based smart contract - written in
// Solidity / Vyper.
//
// It is structured as a JSON array of ABI entries, each of which can be
// a function, event or error definition.
type ABI []Entry

// EntryType is an enum of the possible ABI entry types
type EntryType string

const (
	Function    EntryType = "function"    // A function/method of the smart contract
	Constructor EntryType = "constructor" // The constructor
	Receive     EntryType = "receive"     // The "receive Ethere" function
	Fallback    EntryType = "fallback"    // The default function to invoke
	Event       EntryType = "event"       // An event the smart contract can emit
	Error       EntryType = "error"       // An error definition
)

type StateMutability string

const (
	Pure       StateMutability = "pure"       // Specified not to read blockchain state
	View       StateMutability = "view"       // Specified not to modify the blockchain state (read-only)
	Payable    StateMutability = "payable"    // The function accepts ether
	NonPayable StateMutability = "nonpayable" // The function does not accept ether
)

// Entry is an individual entry in an ABI - a function, event or error.
//
// Defines the name / inputs / outputs which can be used to generate the signature
// of the function/event, and used to encode input data, or decode output data.
type Entry struct {
	Type            EntryType       `json:"type,omitempty"`            // Type of the entry - there are multiple function sub-types, events and errors
	Name            string          `json:"name,omitempty"`            // Name of the function/event/error
	Payable         bool            `json:"payable,omitempty"`         // Functions only: Superseded by stateMutability payable/nonpayable
	Constant        bool            `json:"constant,omitempty"`        // Functions only: Superseded by stateMutability pure/view
	Anonymous       bool            `json:"anonymous,omitempty"`       // Events only: The event is emitted without a signature (topic[0] is not generated)
	StateMutability StateMutability `json:"stateMutability,omitempty"` // How the function interacts with the blockchain state
	Inputs          []Parameter     `json:"inputs"`                    // The list of input parameters to a function, or fields of an event / error
	Outputs         []Parameter     `json:"outputs"`                   // Functions only: The list of return values from a function
}

// Parameter is an individual typed parameter input/output
type Parameter struct {
	Name         string      `json:"name"`                   // The name of the argument - does not affect the signature
	Type         string      `json:"type"`                   // The canonical type of the parameter
	InternalType string      `json:"internalType,omitempty"` // Additional internal type information that might be generated by the compiler
	Components   []Parameter `json:"components,omitempty"`   // An ordered list (tuple) of nested elements for array/object types
	Indexed      bool        `json:"indexed,omitempty"`      // Events only: Whether the parameter is indexed into one of the topics of the log, or in the log's data segment
}

func (e *Entry) IsFunction() bool {
	switch e.Type {
	case Function, Constructor, Receive, Fallback:
		return true
	default:
		return false
	}
}

func (e *Entry) IsEvent() bool {
	return e.Type == Event
}

func (e *Entry) Signature() string {
	buff := new(strings.Builder)
	buff.WriteString(e.Name)
	buff.WriteRune('(')
	for _, p := range e.Inputs {
		buff.WriteString(p.Signature())
	}
	buff.WriteRune(')')
	return buff.String()
}

func (p *Parameter) Signature() string {
	buff := new(strings.Builder)

	return buff.String()
}
