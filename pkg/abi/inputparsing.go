// Copyright Â© 2022 Kaleido, Inc.
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package abi

import (
	"context"
	"encoding/hex"
	"fmt"
	"math/big"
	"reflect"
	"strings"

	"github.com/hyperledger/firefly-common/pkg/i18n"
)

var (
	strType       = reflect.TypeOf("")
	int64Type     = reflect.TypeOf(int64(0))
	float64Type   = reflect.TypeOf(float64(0))
	stringerType  = reflect.TypeOf(new(fmt.Stringer)).Elem()
	byteSliceType = reflect.TypeOf([]byte{})
)

// getPtrValOrRawTypeNil sees if v is a pointer, with a non-nil value. If so returns that value, else nil
func getPtrValOrNil(v interface{}) interface{} {
	val := reflect.ValueOf(v)
	if val.Kind() == reflect.Ptr && !val.IsNil() {
		return val.Elem().Interface()
	}
	return nil
}

// getStringIfConvertible returns a string if it can be converted, and a bool with a result
func getStringIfConvertible(v interface{}) (string, bool) {
	vt := reflect.TypeOf(v)
	// We do a kind check here, rather than convertible check, because almost all low level types
	// are convertible to string - but you get a horrible results for integers etc.
	if vt.Kind() == reflect.String {
		return reflect.ValueOf(v).String(), true
	}
	if vt.Implements(stringerType) {
		return v.(fmt.Stringer).String(), true
	}
	return "", false
}

// getBytesIfConvertible returns a byte array if the type has that kind
func getBytesIfConvertible(v interface{}) []byte {
	vt := reflect.TypeOf(v)
	if vt.Kind() == reflect.Slice && vt.Elem().Kind() == reflect.Uint8 {
		return reflect.ValueOf(v).Bytes()
	}
	return nil
}

// getInt64IfConvertible returns an int64 if it can be converted, and a bool with a result
func getInt64IfConvertible(v interface{}) (int64, bool) {
	if reflect.TypeOf(v).ConvertibleTo(int64Type) {
		return reflect.ValueOf(v).Convert(int64Type).Interface().(int64), true
	}
	return 0, false
}

// getFloat64IfConvertible returns a float64 if it can be converted, and a bool with a result
func getFloat64IfConvertible(v interface{}) (float64, bool) {
	if reflect.TypeOf(v).ConvertibleTo(float64Type) {
		return reflect.ValueOf(v).Convert(float64Type).Interface().(float64), true
	}
	return 0, false
}

// getIntegerFromInterface takes a bunch of types that could be passed in via Go,
// with a focus on those generated by the result of an Unmarshal using Go's default
// unmarshalling.
func getIntegerFromInterface(ctx context.Context, v interface{}) (*big.Int, error) {
	i := new(big.Int)
	switch vt := v.(type) {
	case string:
		// We use Go's default '0' base integer parsing, where `0x` means hex,
		// no prefix means decimal etc.
		i, ok := i.SetString(vt, 0)
		if !ok {
			return nil, i18n.NewError(ctx, i18n.MsgInvalidIntegerABIInput, vt, v)
		}
		return i, nil
	case *big.Float:
		i, _ := vt.Int(i)
		return i, nil
	case *big.Int:
		return vt, nil
	case float64:
		// This is how JSON numbers come in (no distinction between integers/floats)
		i.SetInt64(int64(vt))
		return i, nil
	case float32:
		i.SetInt64(int64(vt))
		return i, nil
	case int64:
		i.SetInt64(vt)
		return i, nil
	case int32:
		i.SetInt64(int64(vt))
		return i, nil
	case int16:
		i.SetInt64(int64(vt))
		return i, nil
	case int8:
		i.SetInt64(int64(vt))
		return i, nil
	case int:
		i.SetInt64(int64(vt))
		return i, nil
	case uint64:
		i.SetInt64(int64(vt))
		return i, nil
	case uint32:
		i.SetInt64(int64(vt))
		return i, nil
	case uint16:
		i.SetInt64(int64(vt))
		return i, nil
	case uint8:
		i.SetInt64(int64(vt))
		return i, nil
	case uint:
		i.SetInt64(int64(vt))
		return i, nil
	default:
		if str, ok := getStringIfConvertible(v); ok {
			return getIntegerFromInterface(ctx, str)
		}
		vi := getPtrValOrNil(v)
		if vi != nil {
			return getIntegerFromInterface(ctx, vi)
		}
		if i64, ok := getInt64IfConvertible(v); ok {
			return getIntegerFromInterface(ctx, i64)
		}
		return nil, i18n.NewError(ctx, i18n.MsgInvalidIntegerABIInput, vt, v)
	}
}

// getFloatFromInterface takes a bunch of types that could be passed in via Go,
// with a focus on those generated by the result of an Unmarshal using Go's default
// unmarshalling.
func getFloatFromInterface(ctx context.Context, v interface{}) (*big.Float, error) {
	f := new(big.Float)
	switch vt := v.(type) {
	case string:
		// We use Go's default '0' base float parsing, where `0x` means hex,
		// no prefix means decimal etc.
		f, _, err := f.Parse(vt, 0)
		if err != nil {
			return nil, i18n.WrapError(ctx, err, i18n.MsgInvalidFloatABIInput, vt, v)
		}
		return f, nil
	case *big.Float:
		return vt, nil
	case *big.Int:
		return f.SetInt(vt), nil
	case float64:
		// This is how JSON numbers come in (no distinction between integers/floats)
		f.SetFloat64(vt)
		return f, nil
	case float32:
		f.SetFloat64(float64(vt))
		return f, nil
	case int64:
		f.SetFloat64(float64(vt))
		return f, nil
	case int32:
		f.SetFloat64(float64(vt))
		return f, nil
	case int16:
		f.SetFloat64(float64(vt))
		return f, nil
	case int8:
		f.SetFloat64(float64(vt))
		return f, nil
	case int:
		f.SetFloat64(float64(vt))
		return f, nil
	case uint64:
		f.SetFloat64(float64(vt))
		return f, nil
	case uint32:
		f.SetFloat64(float64(vt))
		return f, nil
	case uint16:
		f.SetFloat64(float64(vt))
		return f, nil
	case uint8:
		f.SetFloat64(float64(vt))
		return f, nil
	case uint:
		f.SetFloat64(float64(vt))
		return f, nil
	default:
		if str, ok := getStringIfConvertible(v); ok {
			return getFloatFromInterface(ctx, str)
		}
		vi := getPtrValOrNil(v)
		if vi != nil {
			return getFloatFromInterface(ctx, vi)
		}
		if f64, ok := getFloat64IfConvertible(v); ok {
			return getFloatFromInterface(ctx, f64)
		}
		return nil, i18n.NewError(ctx, i18n.MsgInvalidFloatABIInput, vt, v)
	}
}

// getBoolFromInterface handles bool or string values - no attempt made to map
// integer types to bool
func getBoolFromInterface(ctx context.Context, v interface{}) (bool, error) {
	switch vt := v.(type) {
	case bool:
		return vt, nil
	case string:
		return strings.EqualFold(vt, "true"), nil
	default:
		if str, ok := getStringIfConvertible(v); ok {
			return getBoolFromInterface(ctx, str)
		}
		vi := getPtrValOrNil(v)
		if vi != nil {
			return getBoolFromInterface(ctx, vi)
		}
		return false, i18n.NewError(ctx, i18n.MsgInvalidBoolABIInput, vt, v)
	}
}

// getStringFromInterface converts a go interface that is either a string,
// fmt.Stringable or []byte and returns the string value directly (without
// attempting hex decoding etc.)
func getStringFromInterface(ctx context.Context, v interface{}) (string, error) {
	switch vt := v.(type) {
	case string:
		return vt, nil
	case []byte:
		return string(vt), nil
	default:
		if str, ok := getStringIfConvertible(v); ok {
			return str, nil
		}
		vi := getPtrValOrNil(v)
		if vi != nil {
			return getStringFromInterface(ctx, vi)
		}
		return "", i18n.NewError(ctx, i18n.MsgInvalidStringABIInput, vt, v)
	}
}

// getBytesFromInterface converts input that can be either raw bytes in Go,
// or hex encoded (with or without 0x prefix) string data.
func getBytesFromInterface(ctx context.Context, v interface{}) ([]byte, error) {
	switch vt := v.(type) {
	case []byte:
		return vt, nil
	case string:
		vt = strings.TrimPrefix(vt, "0x")
		hb, err := hex.DecodeString(vt)
		if err != nil {
			return nil, i18n.WrapError(ctx, err, i18n.MsgInvalidHexABIInput, vt, v)
		}
		return hb, nil
	default:
		if ba := getBytesIfConvertible(v); ba != nil {
			return ba, nil
		}
		if str, ok := getStringIfConvertible(v); ok {
			return getBytesFromInterface(ctx, str)
		}
		vi := getPtrValOrNil(v)
		if vi != nil {
			return getBytesFromInterface(ctx, vi)
		}
		return nil, i18n.NewError(ctx, i18n.MsgInvalidHexABIInput, vt, v)
	}
}
